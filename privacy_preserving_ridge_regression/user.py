## user.py
import socket
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import scipy
import math
import phe
import sklearn
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import  StandardScaler
from phe import paillier
import bitstring
from bitstring import Bits
from secrets import token_hex
import copy
from Crypto.Cipher import DES
import pickle
import time


def calculate_beta(L,Y):
    beta = np.empty(Y.shape,dtype=np.float32)
    d = Y.shape[0]
    beta[0] = Y[0] / L[0][0]
    for i in range(1,d):
        s = 0.0
        for j in range(i):
            mul = L[i][j] * beta[j]
            # print(i,j,L[i][j],beta[j],mul)
            s += mul
        #print(Y[i] / s)
        s = Y[i] - s
        beta[i] = s / L[i][i]
    return beta

def calculate_Y(L,b):
    Y = np.empty(b.shape,dtype=np.float32)
    d = b.shape[0]
    LT = L.T
    Y[d-1] = b[d-1] / LT[d-1][d-1]
    for i in reversed(range(d-1)):
        s = 0.0
        for j in range(i+1,d):
            mul = LT[i][j] * Y[j]
            # print(i,j,L[i][j],beta[j],mul)
            s += mul
        #print(Y[i] / s)
        s = b[i] - s
        Y[i] = s / LT[i][i]
    return Y

class User(object):
    def __init__(self,X_train,y_train):
        self.X_train = np.around(X_train,2)
        self.y_train = y_train
    
    def paillier_encrypt(self, A_i, b_i, precision=2):
        '''
           This method encrypts C = (A,b) generated by below method. It iterates through each value of array and \ 
           encrypts it.
        '''
        A_i_enc = np.zeros(A_i.shape,dtype=np.object)
        for i in range(A_i.shape[0]):
            for j in range(A_i.shape[1]):
                #print(A_i[i][j])
                A_i_enc[i][j] = self.public_key.encrypt(A_i[i][j],precision=precision)
                
        b_i_enc = np.zeros(b_i.shape,dtype=np.object)
        for i in range(b_i.shape[0]):
            b_i_enc[i] = self.public_key.encrypt(b_i[i],precision=precision)
        
        return A_i_enc, b_i_enc
    
    def calculate(self):
        '''
        This method generates C = (A,b) from X_train, y_train in users. 
        '''
        A_i, b_i = np.zeros((self.X_train.shape[1],self.X_train.shape[1]),dtype=np.float32), np.zeros(self.X_train.shape[1],dtype=np.float32)
        ## Iterating through each row of data to get matrix of length A = (num_of_features, num_of_features),A = (num_of_features,)
        for x_i,y_i in zip(self.X_train,self.y_train):
            A_i += np.dot(x_i.reshape(len(x_i), 1), x_i.reshape(len(x_i), 1).T)
            b_i += (x_i * y_i)
        #print(A_i,b_i)
        A_i_enc,b_i_enc = self.paillier_encrypt(A_i, b_i, precision=2)
        return A_i_enc, b_i_enc

if __name__ == '__main__':

    ## Loaading dataset and taking columns which will be used as X and one column will be kept as Y.
    ## Setting 85% of data as train and 15% as test.
    df = pd.read_csv('auto-mpg.csv')
    df = df[df['horsepower'] != '?']
    cols = df.columns.tolist()
    cols.remove('mpg')
    cols.remove('car name')
    X = df[cols].values.astype(np.float32)
    y = df['mpg'].values.astype(np.float32)
    X_train, X_test, y_train, y_test = train_test_split(X, y,train_size=.85,test_size=.15)
    sc = StandardScaler()
    X_train = sc.fit_transform(X_train)
    X_test = sc.transform(X_test)
    print(X_train.shape,X_test.shape)
    ## Dividing data into 4 users. finding out length of 1/4th of data which will be used to divided data between users.
    ## This logic can be easily extended to N users.
    fourth = int(X_train.shape[0]/ 4)
    print(fourth)
    print(X_train[:fourth,:].shape,y_train[:fourth].shape)
    print(X_train[fourth:2*fourth,:].shape,y_train[fourth:2*fourth].shape)
    print(X_train[2*fourth:3*fourth,:].shape,y_train[2*fourth:3*fourth].shape)
    print(X_train[3*fourth:,:].shape,y_train[3*fourth:].shape)
    user1 = User(X_train[:fourth,:],y_train[:fourth])
    user2 = User(X_train[fourth:2*fourth,:],y_train[fourth:2*fourth])
    user3 = User(X_train[2*fourth:3*fourth,:],y_train[2*fourth:3*fourth])
    user4 = User(X_train[3*fourth:,:],y_train[3*fourth:])
    
    s = socket.socket()
    host = 'localhost'
    port = 12345
    s.connect((host, port))
    s.send(pickle.dumps('User: Please Send Public Key'))
    key = pickle.loads(s.recv(4096))
    while isinstance(key,str):
	    time.sleep(10)
	    s.close()
	    s = socket.socket()
	    s.connect((host, port))
	    s.send(pickle.dumps('User: Please Send Public Key'))
	    key = pickle.loads(s.recv(1024))
	    
    print('Received Paillier Encryption key from Evaluator ',key)
    user1.public_key = key
    user2.public_key = key
    user3.public_key = key
    user4.public_key = key
    
    print('Calculating C(A,b) for each user started')
    start = time.time()
    for user in [user1, user2, user3, user4]:
        s.close()
        s = socket.socket()
        s.connect((host, port))
        s.send(pickle.dumps('User: Sending Encrypted Messages'))
        s.send(pickle.dumps(user.calculate()))
    print('Calculating C(A,b) for each user completed. Time taken : %.2f seconds'%(time.time() - start))
    
    A = np.dot(X_train.T, X_train)
    print('A : ',np.around(A,3))
    b = np.dot(X_train.T, y_train)
    print('B : ',np.around(b,3))
    L = np.linalg.cholesky(A)
    print('L : ',np.around(L,3))
    Y = calculate_Y(L,b)
    print('Y : ',np.around(Y,3))
    beta = calculate_beta(L,Y)    
    print('Beta :', np.around(beta,3))
    s.close()
